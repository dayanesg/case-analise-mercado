# -*- coding: utf-8 -*-
"""case_analise_mercado.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y1HmL8vjSaBtc0HRMmv6wNmopQZUZacL
"""

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Dados
bairros = ['Pimentas', 'Centro', 'São João', 'Cumbica', 'Taboão']
populacao = [400000, 17142, 73176, 91772, 74933]

# Criar DataFrame
df_populacao = pd.DataFrame({'Bairro': bairros, 'População': populacao})

# Ordenar o DataFrame por população (do maior para o menor)
df_populacao = df_populacao.sort_values(by='População', ascending=False)

# Criar o gráfico
plt.figure(figsize=(10, 6))
sns.barplot(x='Bairro', y='População', data=df_populacao, hue='População', palette="Reds", legend=False)
plt.title('População por Bairro em Guarulhos')
plt.xlabel('Bairro')
plt.ylabel('População')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Dados
bairros = ['Pimentas', 'Centro', 'São João', 'Cumbica', 'Taboão']
faturamento = [350000, 325000, 295000, 340000, 310000]

# Criar DataFrame
df_faturamento = pd.DataFrame({'Bairro': bairros, 'Faturamento Médio': faturamento})

# Ordenar o DataFrame por faturamento (do maior para o menor)
df_faturamento = df_faturamento.sort_values(by='Faturamento Médio', ascending=False)

# Criar o gráfico
plt.figure(figsize=(10, 6))
sns.barplot(x='Bairro', y='Faturamento Médio', data=df_faturamento, hue='Faturamento Médio', palette="OrRd", legend=False)
plt.title('Faturamento Médio Mensal por Bairro em Guarulhos (Ordenado)')
plt.xlabel('Bairro')
plt.ylabel('Faturamento Médio (R$)')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Correlação dos dados coletados, aplicando Análise Multicritério (MCDM) e
# Clusterização para identificar as melhores áreas para expansão

import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from sklearn.cluster import KMeans

# Dados
dados = {
    'Distrito': ['Jaraguá', 'Jabaquara', 'Tucuruvi', 'Butantã'],
    'CPTM/Metrô': [True, True, True, True],
    'População': [211610, 214958, 99599, 51715],
    'Renda Média': [877.50, 9700.00, 2836.56, 2584.46],
    'Densidade Demográfica': [2200000, 3700000, 2200000, 4336],
    'Concorrentes': [2, 4, 3, 2],
    'Zona': ['Norte', 'Sul', 'Norte', 'Oeste']
}

df = pd.DataFrame(dados)

# Normalizar os dados numéricos para a mesma escala
scaler = MinMaxScaler()
df[['População', 'Renda Média', 'Densidade Demográfica', 'Concorrentes']] = scaler.fit_transform(df[['População', 'Renda Média', 'Densidade Demográfica', 'Concorrentes']])

# Converter CPTM/Metrô para numérico (True=1, False=0)
df['Transporte'] = df['CPTM/Metrô'].astype(int)

# Definir pesos para cada critério
pesos = {
    'Transporte': 2,
    'População': 1.5,
    'Densidade Demográfica': 2,
    'Renda Média': 3,
    'Concorrentes': -2  # Peso negativo para concorrentes (menos é melhor)
}

# Calcular a pontuação ponderada para cada distrito
df['Pontuação'] = (
    df['Transporte'] * pesos['Transporte'] +
    df['População'] * pesos['População'] +
    df['Densidade Demográfica'] * pesos['Densidade Demográfica'] +
    df['Renda Média'] * pesos['Renda Média'] +
    df['Concorrentes'] * pesos['Concorrentes']
)

# Classificar os distritos pela pontuação
df = df.sort_values(by='Pontuação', ascending=False)

# Clusterizar os dados para identificar padrões
kmeans = KMeans(n_clusters=2, random_state=42)
df['Cluster'] = kmeans.fit_predict(df[['Transporte', 'População', 'Renda Média', 'Densidade Demográfica', 'Concorrentes']])

import matplotlib.pyplot as plt
import seaborn as sns

# Visualizar os resultados
print(df)

# Gráfico de barras para pontuação
plt.figure(figsize=(10, 6))
sns.barplot(x='Distrito', y='Pontuação', data=df)
plt.title('Pontuação por Distrito')
plt.show()

# Gráfico de dispersão para renda média vs. população
plt.figure(figsize=(10, 6))
sns.scatterplot(x='População', y='Renda Média', hue='Distrito', data=df)
plt.title('Renda Média vs. População')
plt.show()

# Gráfico de dispersão para densidade demográfica vs. renda média
plt.figure(figsize=(10, 6))
sns.scatterplot(x='Densidade Demográfica', y='Renda Média', hue='Distrito', data=df)
plt.title('Densidade Demográfica vs. Renda Média')
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Dados
dados = {
    'Distrito': ['Jaraguá', 'Jabaquara'],
    'População': [211610, 214958],
    'Renda Média': [877.50, 9700.00]
}

df = pd.DataFrame(dados)

# Criar o gráfico
plt.figure(figsize=(10, 6))
plt.subplot(1, 2, 1)  # Subplot para população
sns.barplot(x='Distrito', y='População', data=df, palette=['skyblue', 'salmon'])
plt.title('População por Distrito')

plt.subplot(1, 2, 2)  # Subplot para renda média
sns.barplot(x='Distrito', y='Renda Média', data=df, palette=['skyblue', 'salmon'])
plt.title('Renda Média por Distrito')

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Dados (incluindo densidade demográfica)
dados = {
    'Distrito': ['Jaraguá', 'Jabaquara'],
    'Renda Média': [877.50, 9700.00],
    'Densidade Demográfica': [2200000, 3700000]
}

df = pd.DataFrame(dados)

# Criar o gráfico
plt.figure(figsize=(8, 6))
sns.scatterplot(x='Densidade Demográfica', y='Renda Média', hue='Distrito', data=df, s=200)
plt.title('Renda Média vs. Densidade Demográfica')
plt.xlabel('Densidade Demográfica')
plt.ylabel('Renda Média (R$)')
plt.show()

import matplotlib.pyplot as plt
import pandas as pd
from math import pi

# Dados (incluindo pontuação MCDA)
dados = {
    'Distrito': ['Jaraguá', 'Jabaquara'],
    'Transporte': [1, 1],  # Assumindo que ambos têm transporte público
    'População': [0.98, 1],  # Valores normalizados
    'Renda Média': [0.09, 1],  # Valores normalizados
    'Densidade Demográfica': [0.59, 1],  # Valores normalizados
    'Concorrentes': [1, 0.5]  # Valores normalizados (menos é melhor)
}

df = pd.DataFrame(dados)

# Número de variáveis
categories = list(df)[1:]
N = len(categories)

# Ângulo de cada eixo em um gráfico de radar
angles = [n / float(N) * 2 * pi for n in range(N)]
angles += angles[:1]

# Criar o gráfico
plt.figure(figsize=(8, 8))
ax = plt.subplot(111, polar=True)

# Desenhar um eixo para cada variável + adicionar rótulos
plt.xticks(angles[:-1], categories)

# Desenhar ylabels
ax.set_rlabel_position(0)
plt.yticks([0.25, 0.5, 0.75, 1], ["0.25", "0.5", "0.75", "1"], color="grey", size=7)
plt.ylim(0, 1)

# Plotar cada distrito
for i in range(len(df)):
    values = df.loc[i].drop('Distrito').values.flatten().tolist()
    values += values[:1]
    ax.plot(angles, values, linewidth=2, linestyle='solid', label=df['Distrito'][i])
    ax.fill(angles, values, alpha=0.25)

plt.title('Análise Multicritério por Distrito')
plt.legend(loc='upper right', bbox_to_anchor=(0.1, 0.1))
plt.show()